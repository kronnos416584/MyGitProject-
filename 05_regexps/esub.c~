#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>

#define MAX_GROUPS 9
#define RESULT_SIZE 1024

// Функция для проверки на корректность ссылки на группу в строке замены
void check_substitution_group(const char *substitution, regmatch_t *match) {
    const char *sub_ptr = substitution;

    while (*sub_ptr) {
        if (*sub_ptr == '\\') {
            sub_ptr++;
            if (*sub_ptr >= '1' && *sub_ptr <= '9') {
                int group_num = *sub_ptr - '0';
                if (group_num > MAX_GROUPS || match[group_num].rm_so == -1) {
                    fprintf(stderr, "Invalid group reference \\%c (group does not exist)\n", *sub_ptr);
                    exit(1);
                }
            } else if (*sub_ptr != '\\') {
                fprintf(stderr, "Invalid escape sequence \\%c\n", *sub_ptr);
                exit(1);
            }
            sub_ptr++;
        } else {
            sub_ptr++;
        }
    }
}

void esub(const char *regexp, const char *substitution, const char *input) {
    regex_t regex;
    regmatch_t match[MAX_GROUPS + 1];  // Максимум 9 групп

    // Компиляция регулярного выражения
    if (regcomp(&regex, regexp, REG_EXTENDED)) {
        char errbuf[256];
        regerror(regcomp(&regex, regexp, REG_EXTENDED), &regex, errbuf, sizeof(errbuf));
        fprintf(stderr, "Regex compile error: %s\n", errbuf);
        exit(1);
    }

    // Выполнение регулярного выражения
    if (regexec(&regex, input, MAX_GROUPS + 1, match, 0) == 0) {
        // Проверка строки замены на корректность
        check_substitution_group(substitution, match);

        char result[RESULT_SIZE];  // Строка для хранения результата
        int result_idx = 0;
        const char *sub_ptr = substitution;

        // Обрабатываем строку замены
        while (*sub_ptr) {
            if (*sub_ptr == '\\') {
                sub_ptr++;
                if (*sub_ptr == '\\') {
                    result[result_idx++] = '\\';  // Два слэша -> один
                    sub_ptr++;
                } else if (*sub_ptr >= '1' && *sub_ptr <= '9') {
                    int group_num = *sub_ptr - '0';
                    if (group_num <= MAX_GROUPS && match[group_num].rm_so != -1) {
                        // Копируем соответствующий карман
                        int group_len = match[group_num].rm_eo - match[group_num].rm_so;
                        if (result_idx + group_len >= RESULT_SIZE) {
                            fprintf(stderr, "Buffer overflow during substitution\n");
                            exit(1);
                        }
                        memcpy(result + result_idx, input + match[group_num].rm_so, group_len);
                        result_idx += group_len;
                    } else {
                        fprintf(stderr, "Invalid group reference \\%c\n", *sub_ptr);
                        regfree(&regex);
                        exit(1);
                    }
                    sub_ptr++;
                } else {
                    fprintf(stderr, "Invalid escape sequence \\%c\n", *sub_ptr);
                    regfree(&regex);
                    exit(1);
                }
            } else {
                if (result_idx >= RESULT_SIZE) {
                    fprintf(stderr, "Buffer overflow during substitution\n");
                    exit(1);
                }
                result[result_idx++] = *sub_ptr++;
            }
        }
        result[result_idx] = '\0';

        // Выводим результат
        fwrite(input, 1, match[0].rm_so, stdout);  // Начало строки до замены
        printf("%s", result);  // Заменённая строка
        fwrite(input + match[0].rm_eo, 1, strlen(input) - match[0].rm_eo, stdout);  // Оставшаяся часть строки после замены
    } else {
        // Если совпадений нет, выводим исходную строку
        printf("%s", input);
    }

    regfree(&regex);
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <regexp> <substitution> <string>\n", argv[0]);
        return 1;
    }

    const char *regexp = argv[1];
    const char *substitution = argv[2];
    const char *input = argv[3];

    esub(regexp, substitution, input);

    return 0;
}

